language ESSENCE' 1.0

$ Constraint solving model for M-queens problem clas taking in the board size as the parameter.
given BOARD_SIZE : int

letting RANGE be domain int(1..BOARD_SIZE)
letting DIAG_RANGE be domain int(2..2*BOARD_SIZE)

letting minQueens = BOARD_SIZE/2

$ Want to find an M*M board of {0,1}, where 1 denotes the cell containing a queen.
find rows : matrix indexed by [RANGE] of int(0,1)
find columns : matrix indexed by [RANGE] of int(0,1)
find frontDiagonals : matrix indexed by [DIAG_RANGE] of int(0,1)
$ find backDiagonals : matrix indexed by [DIAG_RANGE] of int(0,1)

$ Want to find the smallest possible solution.
minimising sum(rows) + sum(columns) + sum(frontDiagonals)

such that

$ sum(flatten(result)) >= minQueens,

$(sum row : int(1..BOARD_SIZE/2) . (sum col : RANGE . result[row,col]*)) <= (sum row : int((BOARD_SIZE+2)/2..BOARD_SIZE) . sum(result[row,..])),

$(sum col : int(1..BOARD_SIZE/2) . sum(result[..,col])) <= (sum col : int((BOARD_SIZE+2)/2..BOARD_SIZE) . sum(result[..,col])),


 sum(rows) = sum(columns),
$ sum(columns) = sum(frontDiagonals),
$ sum(frontDiagonals) = sum(backDiagonals),

forAll row : RANGE . 
	forAll col : RANGE .
		rows[row] * columns[col] <= frontDiagonals[row+col],

forAll diag : DIAG_RANGE .
	(frontDiagonals[diag] = 0) \/
	(exists row, col : RANGE . (rows[row] * columns[col] = 1) /\ (row + col = diag)),


$ All fields must be under attack.
forAll row : RANGE .
	forAll col : RANGE .
		(rows[row] + columns[col] + frontDiagonals[row+col] + (exists row2,col2 : RANGE . (row2 != row) /\ (col2 != col) /\ (rows[row2] != 0) /\ (columns[col2] != 0) /\ (|row - row2| = |col - col2|))) >= 1